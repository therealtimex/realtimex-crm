# Programmatic Notes API

## Overview

This document describes how AI agents can programmatically create notes after processing activities.

## Architecture

```
Activity Processing Flow:
┌─────────────────────────────────────────────────────────────────┐
│ 1. Activity Arrives (webhook/upload)                            │
│    → status: "raw"                                               │
│    → Displayed in Activity Timeline                             │
├─────────────────────────────────────────────────────────────────┤
│ 2. AI Agent Claims & Processes                                  │
│    → status: "processing"                                        │
│    → Shows "Processing content..." animation                    │
├─────────────────────────────────────────────────────────────────┤
│ 3. Processing Complete                                          │
│    → status: "completed"                                         │
│    → Extract insights, transcribe, summarize                    │
├─────────────────────────────────────────────────────────────────┤
│ 4. Create Permanent Note (Programmatic API)                     │
│    → AI agent inserts into contactNotes table                   │
│    → Note appears in Notes section                              │
│    → Permanent record of outcome                                │
└─────────────────────────────────────────────────────────────────┘
```

## Database Schema

### `contactNotes` Table

```sql
CREATE TABLE "public"."contactNotes" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "contact_id" BIGINT NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    "sales_id" BIGINT REFERENCES sales(id) ON DELETE CASCADE,
    "text" TEXT,
    "date" TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    "status" TEXT,  -- 'cold', 'warm', 'hot' (for contacts)
    "attachments" JSONB[]
);
```

## API Methods

### Method 1: Using Supabase Client (Recommended)

```typescript
import { supabase } from '@/components/atomic-crm/providers/supabase/supabase';

interface CreateNoteParams {
  contact_id: number;
  sales_id: number;      // AI agent's sales_id
  text: string;          // Note content (summary, outcome, etc.)
  status?: string;       // 'cold', 'warm', 'hot'
  attachments?: any[];   // Optional file attachments
  date?: string;         // ISO timestamp (defaults to now)
}

async function createNote(params: CreateNoteParams) {
  const { data, error } = await supabase
    .from('contactNotes')
    .insert({
      contact_id: params.contact_id,
      sales_id: params.sales_id,
      text: params.text,
      status: params.status || 'warm',
      attachments: params.attachments || null,
      date: params.date || new Date().toISOString(),
    })
    .select()
    .single();

  if (error) {
    console.error('Failed to create note:', error);
    throw error;
  }

  return data;
}
```

### Method 2: Using Service Role (Backend/Edge Functions)

For AI agents running in Supabase Edge Functions:

```typescript
import { createClient } from '@supabase/supabase-js';

// Use service_role key for backend operations
const supabaseAdmin = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

async function createNoteAsAgent(
  contactId: number,
  agentSalesId: number,
  noteText: string,
  status: string = 'warm'
) {
  const { data, error } = await supabaseAdmin
    .from('contactNotes')
    .insert({
      contact_id: contactId,
      sales_id: agentSalesId,
      text: noteText,
      status: status,
      date: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}
```

## Example Use Case: Processing Call Recording

```typescript
// After AI processes a call recording activity
async function processCallActivity(activity: Activity) {
  // 1. Update activity status
  await supabase
    .from('activities')
    .update({
      processing_status: 'processing',
      processed_data: { transcript: '...' }
    })
    .eq('id', activity.id);

  // 2. Transcribe and analyze call
  const transcript = await transcribeAudio(activity.raw_data.url);
  const summary = await summarizeCall(transcript);
  const sentiment = await analyzeSentiment(transcript);

  // 3. Update activity with results
  await supabase
    .from('activities')
    .update({
      processing_status: 'completed',
      processed_data: {
        transcript,
        summary,
        sentiment,
      }
    })
    .eq('id', activity.id);

  // 4. Create permanent note with outcome
  await createNote({
    contact_id: activity.contact_id,
    sales_id: activity.sales_id,  // AI agent's ID
    text: `Call Summary: ${summary}\n\nKey Points:\n${extractKeyPoints(transcript)}`,
    status: sentiment === 'positive' ? 'hot' : 'warm',
  });

  // Note now appears in the permanent Notes section!
}
```

## Testing the API

### Manual Test (Browser Console)

```javascript
// Open browser console on contact page
const { supabase } = await import('@/components/atomic-crm/providers/supabase/supabase');

// Create a test note
const result = await supabase
  .from('contactNotes')
  .insert({
    contact_id: 1,  // Replace with actual contact ID
    sales_id: 1,    // Replace with actual sales ID
    text: 'Test note created programmatically by AI agent',
    status: 'warm',
  })
  .select()
  .single();

console.log('Note created:', result);
```

### Automated Test (Vitest)

```typescript
import { describe, it, expect } from 'vitest';
import { supabase } from '@/components/atomic-crm/providers/supabase/supabase';

describe('Programmatic Note Creation', () => {
  it('should create a note for a contact', async () => {
    const { data, error } = await supabase
      .from('contactNotes')
      .insert({
        contact_id: 1,
        sales_id: 1,
        text: 'Test note',
        status: 'warm',
      })
      .select()
      .single();

    expect(error).toBeNull();
    expect(data.id).toBeDefined();
    expect(data.text).toBe('Test note');
  });
});
```

## Row Level Security (RLS)

The `contactNotes` table has RLS enabled with permissive policies:

```sql
-- Current policy (permissive)
CREATE POLICY "Allow authenticated users" ON contactNotes
  FOR ALL USING (true);
```

**Note:** All authenticated users can create/read/update/delete notes. If you need data isolation, update the RLS policies to restrict access based on `sales_id` or parent-child relationships.

## Best Practices

1. **Always set `sales_id`** - Track which agent (human or AI) created the note
2. **Use meaningful text** - Include summaries, key points, action items
3. **Set appropriate status** - Use 'hot' for high-value interactions, 'warm' for neutral, 'cold' for low-engagement
4. **Handle errors gracefully** - Log failures and retry if necessary
5. **Avoid duplicates** - Check if a note already exists before creating
6. **Keep notes concise** - Aim for 1-3 paragraphs maximum

## API Reference

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `contact_id` | bigint | ✅ Yes | - | Foreign key to contacts table |
| `sales_id` | bigint | ✅ Yes | - | Agent who created the note |
| `text` | text | ❌ No | null | Note content |
| `date` | timestamp | ❌ No | now() | When the note was created |
| `status` | text | ❌ No | null | Contact status ('cold', 'warm', 'hot') |
| `attachments` | jsonb[] | ❌ No | null | File attachments |

## Next Steps

- Integrate this API into your AI agent's activity processing pipeline
- Set up monitoring/logging for programmatic note creation
- Configure RLS policies if you need data isolation
- Add webhooks to notify users when AI creates notes
